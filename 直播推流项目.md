# 基于ffmpeg的直播双边滤波美颜推流项目
## 项目介绍
作为一个目标为C++开发人员，为了更好的了解C++开发知识，并且为以后所要从事的具体方向做一点基础准备，所以这里选择了C++较为擅长的一个领域，也即音视频处理相关方向，所以选择了做一个直播推流项目。在该项目中，基本过程可以分解为**采集、处理、编码封装、推流传输**，其中，
- 采集分为音频采集和视频采集，他们有各自由qt提供多线程方式执行线程，而其中音频是qt库提供QAudioInput，视频是由opencv提供的VideoCapture，并且通过缓冲队列的方式实现数据存储（链表实现）。
- 处理过程同样要区分音频和视频，其中音频只是做了一个重采样处理，而视频则通过了一个opencv库内的双边滤波算法处理美颜效果，并且进行RGB转YUV格式转换。
- 编码封装，将音频采样数据PCM转换为acc格式，视频数据压缩为h.264格式。
- 推流是基于ffmpeg通过rtmp协议将数据上传至流媒体服务器，也即nigix_rtmpmo模块中处理。并且而已通过flash进行web拉流。
## 项目难点和重点
1、音视频同步问题：
```
由于我们并不能保证获取每一帧音视频的时间长短是固定在某一个定值的，而是会因为内部性能等原因导致时间上的差距，这样为了保证在进行音视频流推送的同步问题上，这里选通过外部时钟记时间的方法保存每一帧音视频录制时的时间戳，在通过rtmp协议进行上传音视频数据时，将时间戳作为参数处理。这样我们就能得到一个音视频时间准确的信息流数据。
在项目中，涉及到的具体实现有
- 时间戳函数--av_gettime();来自于 **#include <libavutil/time.h>** 得到的是一个微妙单位的时间戳。
- av_rescale_q(pack->pts, stime, dtime);编码和推流的timebase会有变化，编码是使用帧率进行计算的。推流时要改为使用推流时的timebase重新进行计算。
- 时间戳pts的的截取选择在录制音视频帧阶段，这样可以保证不会因为内部缓存的影响而导致时间出现问题。
- 
```
2、qt多线程处理
```
由于本身音频与视频数据采集并不是同步进行的，并且这里设置的直播方式为数据采集线程处理，推流线程处理。这样，对多核cpu的应用也能够更充分，并且实现逻辑更简单。在该程序中，选择qt线程类QThread来实现多线程方法，通过继承QThread并且重载run方法实现子线程逻辑。当然qt还有一些其他的创建线程接口方法，如movetothread，不过，对于常驻类型任务需求，run方法可以更好的利用这个处理逻辑。
这里子线程的推出则是通过主线程管理，主线程通过设置（bool）isExit变量值来使得run方法中while退出，这个退出不是即时的，需要将while中的主体程序运行完并再次判断条件时不满足退出。
```
## 涉及的知识点及问题
1、 保存音频和视频帧信息的数据格式?
```
首先，程序中通过一个XData类对象来统一管理音视频采集信息和采集时间，在真正需要具体的类型数据时，比如完成推流操作，这是会通过AVPacket结构保存数据，它保存着pts，dts，数据大小。视频还存在一个mat 数据类型。
```
2、 音频为什么要进行重采样和编码?
```
采样率的大小会决定整体的数据量大小，而人耳可听见音频是有范围的，这样就决定了不需要将采样频率设置过大浪费空间，但同时又不能设置的太小导致音频失真，目前一般采用44.1hz大小。而编码则是将原始数据转换为acc格式，这样目的也是为了进行数据压缩，也叫做有损压缩。项目实现函数avcodec_send_frame，前面需要进行初始化音频编码器。
```
3、 视频如何进行美颜处理？
```
项目中通过使用opencv库函数**bilateralFilter(*src, *des, d, d * 2, d / 2);**实现，对于双边滤波算法；项目通过XFilter作为算法接口，管理处理方法。
```
4、 视频从rgb转yuv的实现过程？
```
在视频采集过程中，会获得原始的rgb图像，在处理数据过程中，会先将rgb数据转换为yuv格式，涉及到的具体函数**sws_scale**，这样做可以节省一定空间，因为人眼对色彩不是特别铭感而对亮度则较为铭感，因为YUV分量中，UV分量对人眼来说不敏感，因此可以降低采样率。
```
5、设置工厂模式
设置工厂管理方法管理对象的生成，对于要生成对象类，通过get方法静态管理，这样，能够封装实际对象的创建过程，三种类型模式，简单工厂模式、工厂方法模式、抽象工厂模式。其中，由于项目便于管理，这里使用的事直接工厂模式，也即第二种，实现直接实现具体的类对象。
 

 ## 流媒体协议
 ### rtmp介绍
 - RTMP协议封包 由一个包头和一个包体组成,包头可以是4种长度的任意一种:12, 8, 4,  1 byte(s).完整的RTMP包头应该是12bytes,包含了时间戳,Head_Type,AMFSize,AMFType,StreamID信息, 8字节的包头只纪录了时间戳,Head_Type,AMFSize,AMFType, 4个字节的包头记录了时间戳,Head_Type。1个字节的包头只记录了Head_Type 。包体最大长度默认为128字节,通过chunkSize可改变包体最大长度,通常当一段AFM数据超过128字节后,超过128的部分就放到了其他的RTMP封包中,包头为一个字节。
 文章：吃透rtmp https://www.jianshu.com/p/b2144f9bbe28