# 计算机系统
## 进程
### 进程基本概念
进程的经典定义是一个执行中程序的实例，同时也是**资源分配的最小单元**。系统中的每个程序都运行在某个进程中的上下文中，上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的**代码**和**数据**，它的**栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合**。
#### 状态
##### 三态模型：在多道程序系统中，进程在处理器上交替运行，状态也不断地发生变化。进程一般有3种基本状态：运行、就绪和阻塞。

1、 就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I／O操作完成而进入就绪状态时，排入高优先级队列。

2、 运行：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程只有一个。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。

3、 阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。

##### 五态模型：对于一个实际的系统，进程的状态及其转换更为复杂。引入新建态和终止态构成了进程的五态模型。

1、 新建态： 对应于进程刚刚被创建时没有被提交的状态，并等待系统完成创建进程的所有必要信息。 进程正在创建过程中，还不能运行。操作系统在创建状态要进行的工作包括分配和建立进程控制块表项、建立资源表格（如打开文件表）并分配资源、加载程序并建立地址空间表等。创建进程时分为两个阶段，第一个阶段为一个新进程创建必要的管理信息，第二个阶段让该进程进入就绪状态。由于有了新建态，操作系统往往可以根据系统的性能和主存容量的限制推迟新建态进程的提交。

2、终止态：进程已结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中收集有关信息（如记帐和将退出代码传递给父进程）。类似的，进程的终止也可分为两个阶段，第一个阶段等待操作系统进行善后处理，第二个阶段释放主存。
由于进程的不断创建，系统资源特别是主存资源已不能满足所有进程运行的要求。这时，就必须将某些进程挂起，放到磁盘对换区，暂时不参加调度，以平衡系统负载；进程挂起的原因可能是系统故障，或者是用户调试程序，也可能是需要检查问题。

3、活跃就绪：是指进程在主存并且可被调度的状态。

4、静止就绪（挂起就绪）：是指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或者是挂起就绪态进程具有更高的优先级，系统将把挂起就绪态进程调回主存并转换为活跃就绪。

5.1、活跃阻塞：是指进程已在主存，一旦等待的事件产生便进入活跃就绪状态。

5.2、静止阻塞：是指进程对换到辅存时的阻塞状态，一旦等待的事件产生便进入静止就绪状态。
#### 进程控制块
进程控制块（PCB，Process Control Block），是操作系统核心中一种数据结构，主要表示进程状态。

虽各实际情况不尽相同，PCB通常记载进程之相关信息，包括：

- 进程状态：可以是new、ready、running、waiting或 blocked等。
- 程序计数器：接着要运行的指令地址。
- CPU寄存器：如累加器、变址寄存器、堆栈指针以及一般用途寄存器、状况代码等，主要用途在于中断时暂时存储数据，以便稍后继续利用；其数量及类别因电脑架构有所差异。
- CPU排班法：优先级、排班队列等指针以及其他参数。
- 内存管理：如页表等。
- 会计信息：如CPU与实际时间之使用数量、时限、账号、工作或进程号码。
- 输入输出状态：配置进程使用I/O设备，如磁带机。
总言之，PCB如其名，内容不脱离各进程相关信息。

### 进程间通信
进程间通信方式一般认为有六种，分别是管道、消息队列、共享内存、信号量、信号、socket
#### 管道
匿名管道和命名管道
- 管道pipe：管道是一种半双工的通信方式，数据只能**单向流动**，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。调用pipe函数，会在内核中开辟出一块**缓冲区**用来进行进程间通信，这块缓冲区称为管道，它有一个**读端**和一个**写端**。比如：
>> 父进程创建管道，得到两个文件描述符指向管道的两端
>> 利用fork函数创建出子进程，则子进程也得到两个文件描述符指向同一管道
>> 父进程关闭读端（pipe[0]）,子进程关闭写端pipe[1]，则此时父进程可以往管道中进行写操作，子进程可以从管道中读，从而实现了通过管道的进程间通信。(半双工的过程)
**pipe的特点**：
1. 只能单向通信
2. 只能血缘关系的进程进行通信
3. 依赖于文件系统
4. 生命周期随进程
5. 面向字节流的服务
6. 管道内部提供了同步机制

- 命名管道FIFO: FIFO可以在**无关的进程之间**交换数据，与无名管道不同。
FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。
其中的 mode 参数与open函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。
当 open 一个FIFO时，是否设置非阻塞标志（O_NONBLOCK）的区别：
若没有指定O_NONBLOCK（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。
若指定了O_NONBLOCK，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。

#### 消息队列MessageQueue: 
- 消息队列是由消息的**链表**，**存放在内核中**并由**消息队列标识符**标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
1. 消息队列是**面向记录**的，其中的消息具有特定的格式以及特定的**优先级**。
2. 消息队列**独立于发送与接收进程**。进程终止时，消息队列及其内容并**不会被删除**。
3. 消息队列可以实现消息的**随机查询**,消息不一定要以先进先出的次序读取,也可以按消息的**类型读取**。

#### 共享内存SharedMemory: 
共享内存是系统出于多个进程之间通讯的考虑，而预留的的一块内存区。
- 当一个程序加载进内存后，它就被分成叫作页的块。

- 通信将存在内存的两个页之间或者两个独立的进程之间。

总之，当一个程序想和另外一个程序通信的时候，那内存将会为这两个程序生成一块公共的内存区域。这块被两个进程分享的内存区域叫做共享内存

因为所有进程共享同一块内存，共享内存在各种进程间通信方式中具有最高的效率。访问共享内存区域和访问进程独有的内存区域**一样快**，并不需要通过系统调用或者其它需要切入内核的过程来完成。同时它也避免了对数据的各种不必要的复制。

为了简化共享数据的完整性和避免同时存取数据，内核提供了一种专门存取共享内存资源的机制。这称为互斥体或者mutex对象

#### 信号量Semaphore: 
信号量本质上是一个**计数器**（不设置全局变量是因为进程间是相互独立的，而这不一定能看到，看到也不能保证++引用计数为原子操作）,用于多进程对共享数据对象的读取，它和管道有所不同，它不以传送数据为主要目的，它主要是用来**保护共享资源**（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。
**信号量在进行操作时是原子的。**

#### 信号 ( sinal ):
- 信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。

- 信号是进程间通信机制中唯一的**异步通信机制**，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。信号机制经过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。

#### 套接字Socket:
基于数据报和流，具体过程在计算机网络中分析。
### 进程地址空间 
每个程序都能看到一片完整连续的地址空间，这些空间并没有直接关联到物理内存，而是操作系统提供了内存的一种抽象概念，使得每个进程都有一个连续完整的地址空间，在程序的运行过程，再完成虚拟地址到物理地址的转换。进程的地址空间是分段的，存在所谓的数据段，代码段，bbs段，堆，栈。
![]{../picg/linuxprocessaddressspace02.png}

- 从0xc000000000到0xFFFFFFFF共1G的大小是内核地址空间（后面再探讨内核地址空间，先重点关注用户地址空间），余下的低地址3G空间则是用户地址空间。
- Code VMA: 即程序的代码段，CPU执行的机器指令部分。通常，这一段是可以共享的，即多线程共享进程的代码段。并且，此段是只读的，不能修改。
- Data VMA: 即程序的数据段，包含ELF文件在中的data段和bss段。
- 堆和栈: 这两个大家都十分熟悉了，new或者malloc分配的空间在堆上，需要程序猿维护，若没有主动释放堆上的空间，进程运行结束后会被释放。栈上的是函数栈临时的变量，还有程序的局部变量，自动释放。
- 共享库和**mmap内容映射区**：位于栈和堆之间，例如程序使用的printf，函数共享库printf.o固定在某个物理内存位置上，让许多进程映射共享。mmap是一个系统函数，可以把磁盘文件的一部分直接映射到内存，这样文件中的位置直接就有对应的内存地址。此处参考后面的第三条。
- 命令行参数: 程序的命令行参数
- 环境变量：类似于Linux下的PATH，HOME等环境变量，子进程会继承父进程的环境变量。
## 进程调度算法
这里主要区分两种系统：批处理系统和交互式处理系统。这里时间片轮转是交互式处理系统。
### 先来先服务调度算法（First Come First Served, FCFS）
是最简单的调度算法，可以用于作业调度和进程调度。按照作业进入系统后备作业队列的先后次序来挑选作业，加入就绪队列，等待执行。
### 短作业优先
短作业优先调度算法（Short Job First）用于进程调度时又被称为短进程优先调度算法（Short Process First），该算法既可以用于作业调度，又可以用于进程调度。

在作业调度中，该算法每次从后备作业队列中挑选估计服务时间最短的一个或几个作业，将他们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中的原理类似。
### 最短剩余时间优先
SJF本身是非抢占式的，用于抢占式调度系统时，对应的算法陈伟最短剩余时间优先调度算法。

该算法首先按照作业的服务时间挑选最短的作业运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。该算法确保一旦新的短作业或短进程进入系统，能够很快得到处理。
### 高响应比优先
高响应比优先调度算法（Highest Reponse Ratio First, HRRF）是非抢占式的，主要用于作业调度。

基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。

响应比 = （等待时间 + 服务时间） / 服务时间 = 等待时间 / 服务时间 + 1
### 时间片轮转
用于分时系统的进程调度。

基本思想：系统将CPU处理时间划分为若干个时间片（q），进程按照到达先后顺序排列。每次调度选择队首的进程，执行完1个时间片q后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。该算法能在给定的时间内响应所有用户的而请求，达到分时系统的目的。

其性能主要取决于时间片q的大小，q太大，则所有的进程在1个时间片完成，退外围FCFS；太小则进程频繁切换，系统开销大。

该算法简单有效，常用于分时系统，但不利于I/O频繁的而紧凑，由于这种进程用不完一个时间片，就因为等待I/O操作而被阻塞，当I/O操作结束后，只能插入到就绪队列的末尾，等待下一轮调度。
### fork()函数
- fork：	fork创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容task_struct内容
- vfork：	vfork创建的子进程与父进程共享数据段,而且由vfork()创建的子进程将先于父进程运行
- clone：	Linux上创建线程一般使用的是pthread库 实际上linux也给我们提供了创建线程的系统调用，就是clone

**task_struct:**
```
Linux内核通过一个被称为进程描述符的task_struct结构体来管理进程，这个结构体包含了一个进程所需的所有信息。它定义在include/linux/sched.h文件中。
5个互斥状态
2个终止状态
新增睡眠状态

```
vfork()用法与fork()相似.但是也有区别,具体区别归结为以下3点

fork() 子进程拷贝父进程的数据段，代码段.
vfork() 子进程与父进程共享数据段.|

fork() 父子进程的执行次序不确定.
vfork():保证子进程先运行，

vfork()保证子进程先运行，在她调用exec或_exit之后父进程才可能被调度运行。如果在
调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。

在调用exec或_exit之前与父进程数据是共享的,在它调用exec或_exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。当需要改变共享数据段中变量的值，则拷贝父进程

vfork用于创建一个新进程，而该新进程的目的是exec一个新进程，vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，不会复制页表。因为子进程会立即调用exec，于是也就不会存放该地址空间。不过在子进程中调用exec或exit之前，他在父进程的空间中运行。

如果在调用vfork时子进程依赖于父进程的进一步动作，则会导致死锁。由此可见，这个系统调用是用来启动一个新的应用程序。其次，子进程在vfork()返回后直接运行在父进程的栈空间，并使用父进程的内存和数据。这意味着子进程可能破坏父进程的数据结构或栈，造成失败。

为了避免这些问题，需要确保一旦调用vfork()，子进程就不从当前的栈框架中返回，并且如果子进程改变了父进程的数据结构就不能调用exit函数。

子进程还必须避免改变全局数据结构或全局变量中的任何信息，因为这些改变都有可能使父进程不能继续。通常，如果应用程序不是在fork()之后立即调用exec()，就有必要在fork()被替换成vfork()之前做仔细的检查。


## 线程
### 线程基本概念
 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
### 多线程通信
线程间的通信目的主要是用于**线程同步**，所以线程没有像进程通信中的用于数据交换的通信机制。
- 锁机制：包括互斥锁、条件变量、读写锁
互斥锁提供了以排他方式防止数据结构被并发修改的方法。
读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
- 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

- 信号机制(Signal)：类似进程间的信号处理
### 线程与进程的区别
进程和线程的主要差别在于它们是不同的操作**系统资源管理方式**。进程有**独立的地址空间**，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的**堆栈和局部变量**，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程

1、拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问同一进程的资源
2、调度
线程是独立调度的基本单位，同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程内的线程会引起进程切换

3、系统开销
创建和撤销进程时，系统都要为之分配或回收资源，所付出的开销远大于创建或撤销线程时的开销。同样的在进程切换时，也会涉及当前执行进程 CPU 环境的保存以及新调度进程 CPU 环境的设置，而线程的切换只需保存和设置少量寄存器的内容，开销很小

4、通信方面
进程间通信需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同意进程中的数据段（如全局变量）来进行通信。
### 线程池
队列：
```
// SafeQueue.h

#pragma once 
#include <mutex> 
#include <queue> 
// Thread safe implementation of a Queue using a std::queue

template <typename T>
class SafeQueue {
private:
  std::queue<T> m_queue; //利用模板函数构造队列

  std::mutex m_mutex;//访问互斥信号量

public:
  SafeQueue() { //空构造函数


  }

  SafeQueue(SafeQueue& other) {//拷贝构造函数

    //TODO:
  }

  ~SafeQueue() { //析构函数

  }


  bool empty() {  //队列是否为空

    std::unique_lock<std::mutex> lock(m_mutex); //互斥信号变量加锁，防止m_queue被改变

    return m_queue.empty();
  }
  
  int size() {
    std::unique_lock<std::mutex> lock(m_mutex); //互斥信号变量加锁，防止m_queue被改变

    return m_queue.size();
  }
//队列添加元素

  void enqueue(T& t) {
    std::unique_lock<std::mutex> lock(m_mutex);
    m_queue.push(t);
  }
//队列取出元素

  bool dequeue(T& t) {
    std::unique_lock<std::mutex> lock(m_mutex); //队列加锁

    if (m_queue.empty()) {
      return false;
    }
    t = std::move(m_queue.front()); //取出队首元素，返回队首元素值，并进行右值引用
    
    m_queue.pop(); //弹出入队的第一个元素

    return true;
  }
};
```
线程池：
```
//ThreadPool.h

#pragma once 
#include <functional> 
#include <future> 
#include <mutex> 
#include <queue> 
#include <thread> 
#include <utility> 
#include <vector> 
#include "SafeQueue.h" 
class ThreadPool {
private:
  class ThreadWorker {//内置线程工作类

  private:
    int m_id; //工作id

    ThreadPool * m_pool;//所属线程池

  public:
    //构造函数

    ThreadWorker(ThreadPool * pool, const int id) 
      : m_pool(pool), m_id(id) {
    }
    //重载`()`操作

    void operator()() {
      std::function<void()> func; //定义基础函数类func
      
      bool dequeued; //是否正在取出队列中元素
      
      //判断线程池是否关闭，没有关闭，循环提取

      while (!m_pool->m_shutdown) {
        {
          //为线程环境锁加锁，互访问工作线程的休眠和唤醒

          std::unique_lock<std::mutex> lock(m_pool->m_conditional_mutex);
          //如果任务队列为空，阻塞当前线程

          if (m_pool->m_queue.empty()) {
            m_pool->m_conditional_lock.wait(lock); //等待条件变量通知，开启线程

          }
          //取出任务队列中的元素

          dequeued = m_pool->m_queue.dequeue(func);
        }
        //如果成功取出，执行工作函数

        if (dequeued) {
          func();
        }
      }
    }
  };

  bool m_shutdown; //线程池是否关闭

  SafeQueue<std::function<void()>> m_queue;//执行函数安全队列，即任务队列

  std::vector<std::thread> m_threads; //工作线程队列

  std::mutex m_conditional_mutex;//线程休眠锁互斥变量

  std::condition_variable m_conditional_lock; //线程环境锁，让线程可以处于休眠或者唤醒状态

public:
    //线程池构造函数

  ThreadPool(const int n_threads)
    : m_threads(std::vector<std::thread>(n_threads)), m_shutdown(false) {
  }

  ThreadPool(const ThreadPool &) = delete; //拷贝构造函数，并且取消默认父类构造函数

  ThreadPool(ThreadPool &&) = delete; // 拷贝构造函数，允许右值引用

  ThreadPool & operator=(const ThreadPool &) = delete; // 赋值操作

  ThreadPool & operator=(ThreadPool &&) = delete; //赋值操作

  // Inits thread pool

  void init() {
    for (int i = 0; i < m_threads.size(); ++i) {
      m_threads[i] = std::thread(ThreadWorker(this, i));//分配工作线程

    }
  }

  // Waits until threads finish their current task and shutdowns the pool

  void shutdown() {
    m_shutdown = true;
    m_conditional_lock.notify_all(); //通知 唤醒所有工作线程
    
    for (int i = 0; i < m_threads.size(); ++i) {
      if(m_threads[i].joinable()) { //判断线程是否正在等待

        m_threads[i].join();  //将线程加入等待队列

      }
    }
  }

  // Submit a function to be executed asynchronously by the pool
  //线程的主要工作函数，使用了后置返回类型，自动判断函数返回值

  template<typename F, typename...Args>
  auto submit(F&& f, Args&&... args) -> std::future<decltype(f(args...))> {
    // Create a function with bounded parameters ready to execute
    // 

    std::function<decltype(f(args...))()> func = std::bind(std::forward<F>(f), std::forward<Args>(args)...);//连接函数和参数定义，特殊函数类型,避免左、右值错误

    // Encapsulate it into a shared ptr in order to be able to copy construct // assign 
    //封装获取任务对象，方便另外一个线程查看结果

    auto task_ptr = std::make_shared<std::packaged_task<decltype(f(args...))()>>(func);

    // Wrap packaged task into void function
    //利用正则表达式，返回一个函数对象

    std::function<void()> wrapper_func = [task_ptr]() {
      (*task_ptr)(); 
    };

    // 队列通用安全封包函数，并压入安全队列

    m_queue.enqueue(wrapper_func);

    // 唤醒一个等待中的线程

    m_conditional_lock.notify_one();

    // 返回先前注册的任务指针

    return task_ptr->get_future();
  }
};
```
## 中断
中断指处理机处理程序运行中出现的紧急事件的整个过程.程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序(中断服务程序)，待处理完后，再返回原来的程序运行，这整个过程称为程序中断。

 CPU要做的事情：
 改变工作模式至中断模式
```
保存现场

分析中断原因，跳到中断起始地址处理中断

返回到原来模式

恢复现场继续执行原来的程序。
```
---
layout: post
title: linux下的中断机制
categories: [linux]
description: linux interrupt 中断
keywords: linux interrupt 中断
---
文章来源：https://github.com/lrita/lrita.github.io
### 中断的定义与种类

Linux中的中断异常机制[^1]：

> 中断（interrupt）被定义为一个事件，该事件改变处理器执行的指令顺序，这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。**中断通常分为同步（synchronous）中断和异步（asynchronous）中断**。
>
> * 同步中断指的是当指令执行时由CPU控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断。
> * 异步中断是由其他硬件设备依照CPU时钟信号随机产生的。
>
> 在Intel处理器中，**把同步中断和异步中断分别称为异常（exception）和中断（interrupt）**。我们这里也采用这种分类。我们也使用中断信号来统称中断和异常。
>
> 中断是由间隔定时器和I/O设备产生的，例如，用户的一次按键会引起一个中断，虽然用户没有感觉，但是按键这个过程到下一次按键之间的间隔对于计算机指令时间来说是非常长的。
>
> 另一方面，异常是由程序的错误产生的，或者由内核必须处理的异常条件产生的。第一种情况下，内核通过发送一个每个Unix程序员都熟悉的信号来处理异常，第二种情况下，内核执行恢复异常需要的所有步骤，例如缺页异常。
>
> �����断信号提供了一种特殊的方式，使处理器转而去运行正常的控制流之外的代码。当一个中断信号到达时，CPU必须停止它当前正在做的事情，保留上下文，并切换产生中断后的一个空间。
>
> 虽然进程切换和中断都会导致内核保存上下文并且切换到另一空间，但中断处理程序和进程切换有一个明显的差异，由中断或异常处理程序执行的代码不是一个进程，更确切的说，它是一个内核执行路径，代表中断发生时正在运行的进程执行。作为一个内核控制路径，中断处理程序要比一个进程更轻量。
>
> 中断处理是由内核执行的最敏感的任务之一，因此它必须满足下面的约束：
>
> 当内核正打算去完成一些别的事情时，中断会随时到来。因此，内核的目标就是让中断尽可能快的处理完，尽其所能把更多的处理向后推迟。例如一个数据块已经到达了网线，当硬件中断内核时，内核只简单的标志数据到来了，让处理器恢复到它以前的运行状态，其余的处理稍后再进行。因此，内核响应中断后需要进行的操作氛围两部分，关键而紧急的部分内核立即执行，其他的推迟的部分内核随后会执行。
>
> 因为中断随时到来，所以内核可能正在处理其中一个中断的时候，另一个中断又会到来，应该尽可能多的允许这样的情况发生，因为这能维持更多的I/O设备处于忙状态，提高I/O设备的吞吐量。因此中断处理程序必须便写成使相应的内核控制路径能以嵌套的方式执行。当最后一个内核控制路径终止时，内核必须能恢复被中断执行的进程。
>
> 尽管内核在处理前一个中断时可以接受一个新的中断，但在内核代码中还是存在一些临界区，在临界区中，中断必须被禁止。必须尽可能的限制这样的临界区，因为根据以前的要求，内核，尤其时中断处理程序，应该在大部分时间内以开中断的方式运行。
>
> Intel文档把中断和异常分为以下几类：
>
> 中断：
>
> * 可屏蔽中断，I/O设备发出的所有中断请求（IRQ）都产生可屏蔽中断，一个屏蔽的中断只要还是屏蔽的，控制单元就可以忽略它。
> * 非屏蔽中断，有一些危险的事件才能引起非屏蔽中断，例如硬件故障，非屏蔽中断总是由CPU辨认。
>
> 异常：
>
> 当CPU执行指令时探测到一个异常，会产生一个处理器探测异常（processor-detected exception），可以进一步区分，这取决于CPU控制单元产生异常时保存在内核堆栈eip寄存器的值。
>
> * 故障（fault），通常可以纠正，一旦纠正，程序就可以重新开始，保存在eip寄存器中的值是引起故障的指令地址。
> * 陷阱（trap）在陷阱指令执行后立即报告，内核把控制权烦给程序后就可以继续它的执行而不失连续性。保存在eip中的值是一个随后要执行的指令地址。陷阱的主要作用是为了调试程序。
> * 异常中止（abort），发生一个严重的错误，控制单元出了问题，不能在eip寄存器中保存引起异常的指令所在的确切位置。异常中止用于报告严重的错误，例如硬件故障或系统表中无效的值或者不一致的值。这种异常会强制中止进程。
> * 编程异常（programmed exception），在编程者发出的请求时发送，是由int或int3指令触发的。
>
> 每个中断和异常是由0～255之间的一个数来标识的，Intel把这个8位无符号整数叫做一个向量（vector）。非屏蔽中断的向量和异常的向量是固定的，而可屏蔽中断的向量是可以通过对中断控制器的编程来改变。

在X86中，分为实模式和保护模式，实模式通常是CPU启动到BIOS再到操作系统启动前的这段时间，操作启动初始化完成进入到保护模式。在不同模式下中断的处理机制同步，在这里只**简单探讨一下保护模式下的中断机制**。

### 中断的初始化

Intel X86位处理器有256个硬中断号，用一个8位的无符号整数表示，被叫做一个向量（vector）。

> 中断描述符表（Interrupt Descriptor Table，`IDT`）是一个系统表，它与每一个中断或异常向量相联系，每一个向量在表中有相应地中断或异常处理程序地入口地址，内核在允许中断发生前，必须适当地初始化IDT。

在`IDT`中可以存储以下三种`Gate Descriptor`（门描述符）：用于描述和控制`Interrupt Service Routine`（每个中断对应的回调函数）的访问，它们分别是：
* Interrupt Gate Descriptor（中断门描述符），包含段选择符和中断或异常处理程序地段内偏移量，当控制权转移到一个适当地段时，处理器清IF标志，从而关闭将来会发生的可屏蔽中断。
* Trap Gate Descriptor（陷井门描述符），和中断门类似，只是控制权传递到一个适当地段处理器不修改IF标志。
* Task Gate Descriptor（任务门描述符），Linux中未使用该类型，当中断信号发生时，必须取代当前进程地那个进程地TSS选择符存放在任务门中。

> `IDT`表中地每一项`Gate Descriptor`由8个字节组成，因此，最多需要256x8=2048字节来存放IDT（64位时扩展到16个字节）。因为需要增加权限控制等因素，在`IDT`中并不直接关联到`Interrupt Service Routine`。

`IDTR`是一个CPU寄存器，用以存储`IDT`的基地址与段大小，用以快速访问。机器指令`LLDT`和`SLDT`是分别用来设置和保存`LDTR`寄存器的值[^2]。

![](/images/posts/linux/062111_1451_x86x8664CPU11_IDTR.png)

在内核初始化的时候，会为每一个中断向量注册一个对应的回调函数（`Interrupt Service Routine`），初始化`IDT`与`IDTR`寄存器：
```c
// init/main.c
asmlinkage void __init start_kernel(void)
{
    ...
    setup_arch(&command_line); // 初始化架构相关的，其中包含一些与架构相关的中断，
                               // Page Fault相关的中断就在其内部注册
    ...
    trap_init();    // 初始化异常处理
    ...
    init_IRQ();     // 初始化外部中断
    ...
    init_timers();  // 初始化定时器模块，同时，会注册定时器的软中断处理函数
    ...
    softirq_init(); // 初始化软中断
}

// 在setup_arch中会调用early_trap_pf_init/early_trap_init，其中会注册
// Page Fault异常对应的中断函数page_fault
/* Set of traps needed for early debugging. */
void __init early_trap_init(void)
{
    set_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);
    /* int3 can be called from all */
    set_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
    set_intr_gate(X86_TRAP_PF, &page_fault);
#endif
    load_idt(&idt_descr);
}

void __init early_trap_pf_init(void)
{
#ifdef CONFIG_X86_64
    set_intr_gate(X86_TRAP_PF, &page_fault);
#endif
}
```

更加详细的流程可以参考下面几张图，出自[^3]。

![](/images/posts/linux/interrupt-0.png)

![](/images/posts/linux/interrupt-1.jpg)

![](/images/posts/linux/interrupt-2.jpg)

![](/images/posts/linux/interrupt-3.jpg)

在初始化完成后，每个中断向量都会有一个对应的回调函数（`Interrupt Service Routine`），不同的中断向量对应不同的软件逻辑，如果系统不关心，则置为`ignore_int`：

| 中断向量号 | 异常事件 | Linux的函数 |
| -------- | ------ | ---------- |
| 0 | 除法错误 | divide_error |
| 1 | 调试异常 | debug |
| 2 | NMI中断 | nmi |
| 3	| 单字节，int 3 | int3 |
| 4 | 溢出 | overflow |
| 5 | 边界监测中断 | bounds |
| 6 | 无效操作码 | invalid_op |
| 7 | 设备不可用 | device_not_available |
| 8 | 双重故障 | double_fault |
| 9 | 协处理器段溢出 | coprocessor_segment_overrun |
| 10 | 无效TSS | invalid_TSS |
| 11 | 缺段中断 | segment_not_present |
| 12 | 堆栈异常 | stack_segment |
| 13 | 一般保护异常 | general_protection |
| 14 | 页异常 | page_fault |
| 15 | | spurious_interrupt_bug |
| 16 | 协处理器出错 | coprocessor_error |
| 17 | 对齐检查中断 | alignment_check |
| 0x80 | 系统调用 | ia32_syscall |
| 0xf9 | 内核调试 | call_debug |

上面表格中的这些对应函数，都只是由汇编实现的跳转函数，他们的实现在`arch/x86/kernel/entry_64.S`，基本上都是处理一下必要的上下文，然后跳转到相关的C实现的函数`do_xxx`中[^4]。

| 中断向量号 | 异常事件 | Linux汇编 | 调用c函数 | 处理结果 |
| 0 | 除法错误 | divide_error | do_divide_error | 发送SIGFPE信号 |
| 1	| 调试异常 | debug | do_debug | 发送SIGTRAP信号 |
| 2 | NMI中断 | nmi | do_nmi | |
| 3 | 单字节，int 3 | int3 | do_int3 | 发送SIGTRAP信号 |
| 4 | 溢出 | overflow | do_overflow | 发送SIGSEGV信号 |
| 5 | 边界监测中断 | bounds | do_bounds | 发送SIGSEGV信号 |
| 6	| 无效操作码 | invalid_op | do_invalid_op | 发送SIGILL信号 |
| 7 | 设备不可用 | device_not_available | do_device_not_available | 发送SIGSEGV信号 |
| 8	| 双重故障 | double_fault | do_double_fault |
| 9	| 协处理器段溢出 | coprocessor_segment_overrun | do_coprocessor_segment_overrun | 发送SIGFPE信号 |
| 10 | 无效TSS | invalid_TSS | do_invalid_TSS | 发送SIGSEGV信号 |
| 11 | 缺段中断 | segment_not_present | do_segment_not_present | 发送SIGBUS信号 |
| 12 | 堆栈异常 | stack_segment | do_stack_segment |
| 13 | 一般保护异常 | general_protection | do_general_protection |
| 14 | 页异常 | page_fault | do_page_fault | 处理缺页中断 |
| 15 | | spurious_interrupt_bug | do_spurious_interrupt_bug |
| 16 | 协处理器出错 | coprocessor_error | do_coprocessor_error | 发送SIGFPE信号 |
| 17 | 对齐检查中断 | alignment_check | do_alignment_check | 发送SIGBUS信号 |
| 0x80 | 系统调用 | ia32_syscall |
| 0xf9 | 内核调试 | call_debug | do_call_debug |

### 中断和异常的硬件处理[^5]

#### 中断触发

> 假定内核已经被初始化，因此，CPU在保护模式下运行，Linux只有在刚刚启动的时候是在实模式，之后便进入保护模式。
>
> 在执行了一条指令之后，cs和eip这对寄存器包含下一条将要执行的指令的逻辑地址，在处理了那条指令之后，控制单元会检查在运行前一条指令时是否已经发生了一个中断异或异常。如果发生了一个中断或者异常，那么控制单元执行下列操作：
>
> 1. 确定与中断或异常的关联向量i。
> 2. 读由`IDTR`寄存器指向的`IDT`表中的第i项门描述符。
> 3. 从`GDTR`寄存器获得`GDT`的基地址，并在`GDT`中查找，以读取`IDT`表项中的选择符所标识的段描述符，这个描述符指定中断或异常处理程序所在的段的基地址。
> 4. 确定中断是由授权的中断发生源发出的。(Why？因为INT指令允许用户态的进程产生中断信号，其向量值可以为0到255的任一值，为了避免用户通过INT指令产生非法中断，在初始化的时候，将向量值为80H的门描述符（系统调用使用该门）的DPL设为3，将其他需要避免访问的门描述符的DPL值设为0，这样在做权限检查的时候就可以检查出来非法的情况。)
> 5. 检查是否发生了特权等级变化。如果是由用户态陷入了内核态，控制单元必须开始使用与新的特权级相关的堆栈
>   5.1. 读`TR`寄存器，访问运行进程的`TSS`段。（why？因为任何进程从用户态陷入内核态都必须从`TSS`获得内核堆栈指针。)
>   5.2. 用与新特权级相关的栈段和栈指针装载ss和esp寄存器。这些值可以在进程的`TSS`段中找到。
>   5.3. 在新的栈（内核栈）中保存用户态的ss和esp，这些值指明了用户态相关栈的逻辑地址。
> 6. 如果故障已经发生，用引起异常的指令地址装载cs和eip寄存器，从而使这条指令能够再次被执行。
> 7. 在栈中保存eflags、cs以及eip的内容。
> 8. 如果异常产生了一个硬件出错码，则保存在栈中。
> 9. 装载cs和eip寄存器，其值分别是`IDT`表中的第i项门描述符的段选择符和偏移量，这些值给出了中断或者异常处理程序的第一条指令的逻辑地址（开始执行中断回调函数）。

#### 中断返回

> 中断或异常被处理完毕后，相应的处理程序必须产生一条`iret`指令，把控制权转交给被中断的进程，这样控制单元就会产生以下操作：
>
> 1. 用保存在栈中的值装载cs、eip或eflags寄存器，如果一个硬件出错码曾被押入栈中，并且在eip内容上面，那么执行iret指令必须先弹出这个硬件出错码。
> 2. 检查处理程序的CPL是否等于cs中的最低两位的值，如果是，说明在同一特权级，iret中止执行，否则转入下一步。
> 3. 从栈中装载ss和esp寄存器，返回到与旧特权级相关的栈。
> 4. 检查ds、es、fs以及gs段寄存器的内容，如果其中一个寄存器包含的选择符是个段描述符，并且其DPL值小于CPL，那么就清除相应的段寄存器。
### 软中断
软中断，顾名思义，是由软件产生的中断。不同于硬件中断由硬件发出中断、打断处理器，软中断一般来说是由某个过程发起的，随后打断目的进程的执行，使其执行注册的软中断处理程序。

为什么要有软中断这种东西呢？这涉及到Linux对中断处理过程的实现。Linux将中断处理分成了两个部分：上半部(top-half)和下半部(bottom-half)。上半部完成与硬件紧密相关的工作，一般来说需要关闭中断执行（关闭所在中断线或本地中断）；下半部完成可以在稍后执行的、不那么迫切的工作。由于下半部可以推后执行，因此可以让这部分代码委托给一个进程执行。为了能够告知该进程下半部的执行时机，就需要一种机制，能够中断这个进程，使它执行相应的处理函数。这就是软中断机制的目的。

实际上，下半部更常用的是tasklet，但是它也是由软中断实现的，因此研究软中断机制也是非常有用的。软中断的代码位于 kernel/softirq.c 文件中。
#### 软中断实现
软中断是在编译期静态分配的，它不像tasklet那样可以被动态注册或注销。软中断由一个特有的结构softirq_action表示，它定义在<linux/interrupt.h>中：
```cpp
struct softirq_action
{
    void    (*action)(struct softirq_action *);
};
```
软中断的可用数量是在编译时期固定的，在 kernel/softiqr.c 中定义了一个与之相关的数组：
```
static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;
```
其中，NR_SOFTIRQS 是已经使用的软中断的数量，也定义在该文件中：
**一个软中断不会抢占另一个软中断。实际上，唯一可以抢占软中断的是中断处理程序。不过，其他的软中断（甚至是相同类型的软中断）可以在其他处理器上同时执行。**
一个注册的软中断必须在被标记后才会执行。这被称为触发软中断(raising the softirq)。通常，中断处理程序会在返回前标记它的软中断，使其在稍后执行。于是，在合适的时刻，该软中断就会运行。该触发接口为：

> void raise_softirq(unsigned int nr);
其中nr是软中断处理程序在数组中的对应下标。
#### 软中断的处理时机
待处理的软中断在下面这些地方会被检查和执行：

从一个硬件中断代码返回时；
在ksoftirq内核线程中；
在那些显式检查和执行待处理的软中断的代码中，如网络子系统中。
不管用什么方法唤起，软中断都是在do_softirq()中得到执行的。
**软中断保留给系统中对时间要求最严格以及最重要的下半部使用。如果你想加入一个新的软中断，首先应该问问自己为什么用tasklet实现不了。tasklet可以动态生成，由于它们对加锁的要求不高，所以使用起来也很方便，同时它们的性能也很不错。当然，对于时间要求严格并且能自己高效地完成加锁工作的应用，软中断会是正确的选择。**

## 系统调用
https://blog.csdn.net/gatieme/article/details/50779184
## 内存管理
https://qiankunli.github.io/2019/05/31/linux_memory.html#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86
## 工作队列
https://www.cnblogs.com/ck1020/p/8312652.html
## 虚拟内存
## 页和段高速缓存
https://blog.51cto.com/12118369/1964957
## linux内核相关面试题
https://blog.csdn.net/zhangjikuan/article/details/49021407?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3